{"version":3,"sources":["../node_modules/diff-match-patch/index.js","helpers/merge.js","helpers/throttle.js","helpers/debounce.js","helpers/normalizeContent.js","visuals/getCurve.js","constants.js","visuals/getMode.js","visuals/getTheme.js","visuals/getLine.js","visuals/getEditorHeight.js","visuals/createArrow.js","dom/ensureElement.js","dom/query.js","index.js"],"names":["isObject","item","Array","isArray","module","exports","merge","target","source","Object","keys","forEach","key","assign","callback","wait","immediate","timeout","initialCall","args","callNow","next","apply","setTimeout","context","clearTimeout","normalized","replace","startX","startY","endX","endY","w","halfWidth","DIFF_EQUAL","DIFF_DELETE","DIFF_INSERT","EDITOR_RIGHT","EDITOR_LEFT","RTL","LTR","SVG_NS","DIFF_GRANULARITY_SPECIFIC","DIFF_GRANULARITY_BROAD","C","require","acediff","editor","mode","options","left","right","theme","line","ace","getSession","doc","getLine","document","getElementById","id","offsetHeight","info","el","createElement","props","class","className","style","topOffset","title","tooltip","diffIndex","setAttribute","innerHTML","arrowContent","parent","elClass","guid","Math","random","toString","substr","newId","currentEl","querySelector","appendChild","on","elSelector","eventName","selector","fn","element","addEventListener","event","possibleTargets","querySelectorAll","i","l","length","p","call","parentNode","Range","DiffMatchPatch","throttle","debounce","normalizeContent","getCurve","getMode","getTheme","getEditorHeight","createArrow","ensureElement","query","getRangeModule","requireFunc","acequire","AceDiff","window","undefined","diffGranularity","lockScrolling","showDiffs","showConnectors","maxDiffs","content","editable","copyLinkEnabled","classes","gutterID","diff","connector","newCodeConnectorLink","newCodeConnectorLinkContent","deletedCodeConnectorLink","deletedCodeConnectorLinkContent","copyRightContainer","copyLeftContainer","connectorYOffset","errMessage","console","error","Error","HTMLElement","body","editors","edit","markers","lineLengths","editorHeight","setMode","setReadOnly","setTheme","setValue","lineHeight","renderer","addEventHandlers","createCopyContainers","createGutter","prototype","setOptions","getNumDiffs","diffs","getEditors","dmp","val1","getValue","val2","diff_main","diff_cleanupSemantic","getLineLengths","offset","chunk","index","array","chunkType","text","endsWith","startsWith","push","computeDiff","simplifyDiffs","clearDiffs","decorate","destroy","leftValue","oldDiv","container","newDiv","cloneNode","textContent","replaceChild","rightValue","removeEventHandlers","updateGap","bind","e","copy","onResize","availableHeight","removeEventListener","dir","sourceEditor","targetEditor","startLine","endLine","targetStartLine","targetEndLine","parseInt","getAttribute","leftStartLine","leftEndLine","rightStartLine","rightEndLine","contentToInsert","h","getScrollTop","setScrollTop","lines","getAllLines","showDiff","editorInstance","classNames","session","addMarker","positionCopyContainers","marker","removeMarker","addConnector","leftScrollTop","rightScrollTop","p1_x","p1_y","p2_x","gutterWidth","p2_y","p3_y","p4_x","p4_y","curve1","curve2","verticalLine1","verticalLine2","p3_x","d","createElementNS","gutterSVG","addCopyArrows","arrow","leftTopOffset","rightTopOffset","cssText","diffType","offsetLeft","offsetRight","diffText","lineInfo","newContentStartsWithNewline","test","getSingleDiffInfo","currentLineOtherEditor","getLineForCharPosition","numCharsOnLineOtherEditor","getCharsOnLine","numCharsOnLeftEditorStartLine","startChar","isLastChar","sameLineInsert","numRows","numCharsOnRightEditorStartLine","diffString","endChar","endCharNum","runningTotal","startLineSet","endLineSet","lineLength","lineIndex","endsWithNewline","offsetChars","foundLine","char","startsWithNewline","comparison","gutterHeight","clientHeight","clientWidth","leftHeight","getTotalHeight","rightHeight","height","max","ed","getLength","clearGutter","removeChild","clearArrows","groupedDiffs","compare","val","isGrouped","abs","min","fullDiffs"],"mappings":"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","file":"ace-diff.min.js","sourceRoot":"../src","sourcesContent":["/**\n * Diff Match and Patch\n * Copyright 2018 The diff-match-patch Authors.\n * https://github.com/google/diff-match-patch\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nvar diff_match_patch = function() {\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  this.Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  this.Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close do\n  // the contents have to be to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  this.Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  this.Patch_Margin = 4;\n\n  // The number of bits in an int.\n  this.Match_MaxBits = 32;\n};\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/**\n * Class representing one diff tuple.\n * ~Attempts to look like a two-element array (which is what this used to be).~\n * Constructor returns an actual two-element array, to allow destructing @JackuB\n * See https://github.com/JackuB/diff-match-patch/issues/14 for details\n * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.\n * @param {string} text Text to be deleted, inserted, or retained.\n * @constructor\n */\ndiff_match_patch.Diff = function(op, text) {\n  return [op, text];\n};\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number=} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Diff_Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));\n  }\n  if (commonsuffix) {\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));\n  }\n  this.diff_cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),\n             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),\n             new diff_match_patch.Diff(DIFF_INSERT,\n                 longtext.substring(i + shorttext.length))];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n            new diff_match_patch.Diff(DIFF_INSERT, text2)];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = this.diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],\n                          diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.diff_lineMode_(text1, text2, deadline);\n  }\n\n  return this.diff_bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.diff_linesToChars_(text1, text2);\n  text1 = a.chars1;\n  text2 = a.chars2;\n  var linearray = a.lineArray;\n\n  var diffs = this.diff_main(text1, text2, false, deadline);\n\n  // Convert the diff back to original text.\n  this.diff_charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.diff_cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          var subDiff =\n              this.diff_main(text_delete, text_insert, false, deadline);\n          for (var j = subDiff.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, subDiff[j]);\n          }\n          pointer = pointer + subDiff.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [new diff_match_patch.Diff(DIFF_DELETE, text1),\n          new diff_match_patch.Diff(DIFF_INSERT, text2)];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n *     An object containing the encoded text1, the encoded text2 and\n *     the array of unique strings.\n *     The zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        if (lineArrayLength == maxLines) {\n          // Bail out at 65535 because\n          // String.fromCharCode(65536) == String.fromCharCode(0)\n          line = text.substring(lineStart);\n          lineEnd = text.length;\n        }\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n      lineStart = lineEnd + 1;\n    }\n    return chars;\n  }\n  // Allocate 2/3rds of the space for text1, the rest for text2.\n  var maxLines = 40000;\n  var chars1 = diff_linesToCharsMunge_(text1);\n  maxLines = 65535;\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n  for (var i = 0; i < diffs.length; i++) {\n    var chars = diffs[i][1];\n    var text = [];\n    for (var j = 0; j < chars.length; j++) {\n      text[j] = lineArray[chars.charCodeAt(j)];\n    }\n    diffs[i][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: https://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: https://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n  if (this.Diff_Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                                               shorttext.substring(j));\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                                               shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastEquality = diffs[pointer][1];\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastEquality && (lastEquality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastEquality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastEquality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n  this.diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\n  //   -> <ins>def</ins>xxx<del>abc</del>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = diffs[pointer - 1][1];\n      var insertion = diffs[pointer][1];\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\n      if (overlap_length1 >= overlap_length2) {\n        if (overlap_length1 >= deletion.length / 2 ||\n            overlap_length1 >= insertion.length / 2) {\n          // Overlap found.  Insert an equality and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              insertion.substring(0, overlap_length1)));\n          diffs[pointer - 1][1] =\n              deletion.substring(0, deletion.length - overlap_length1);\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\n          pointer++;\n        }\n      } else {\n        if (overlap_length2 >= deletion.length / 2 ||\n            overlap_length2 >= insertion.length / 2) {\n          // Reverse overlap found.\n          // Insert an equality and swap and trim the surrounding edits.\n          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n              deletion.substring(0, overlap_length2)));\n          diffs[pointer - 1][0] = DIFF_INSERT;\n          diffs[pointer - 1][1] =\n              insertion.substring(0, insertion.length - overlap_length2);\n          diffs[pointer + 1][0] = DIFF_DELETE;\n          diffs[pointer + 1][1] =\n              deletion.substring(overlap_length2);\n          pointer++;\n        }\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 6 (best) to 0 (worst).\n   * Closure, but does not reference any external variables.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 6;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var char1 = one.charAt(one.length - 1);\n    var char2 = two.charAt(0);\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\n    var whitespace1 = nonAlphaNumeric1 &&\n        char1.match(diff_match_patch.whitespaceRegex_);\n    var whitespace2 = nonAlphaNumeric2 &&\n        char2.match(diff_match_patch.whitespaceRegex_);\n    var lineBreak1 = whitespace1 &&\n        char1.match(diff_match_patch.linebreakRegex_);\n    var lineBreak2 = whitespace2 &&\n        char2.match(diff_match_patch.linebreakRegex_);\n    var blankLine1 = lineBreak1 &&\n        one.match(diff_match_patch.blanklineEndRegex_);\n    var blankLine2 = lineBreak2 &&\n        two.match(diff_match_patch.blanklineStartRegex_);\n\n    if (blankLine1 || blankLine2) {\n      // Five points for blank lines.\n      return 5;\n    } else if (lineBreak1 || lineBreak2) {\n      // Four points for line breaks.\n      return 4;\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\n      // Three points for end of sentences.\n      return 3;\n    } else if (whitespace1 || whitespace2) {\n      // Two points for whitespace.\n      return 2;\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\n      // One point for non-alphanumeric.\n      return 1;\n    }\n    return 0;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = diffs[pointer - 1][1];\n      var edit = diffs[pointer][1];\n      var equality2 = diffs[pointer + 1][1];\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n// Define some regex patterns for matching boundaries.\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\ndiff_match_patch.whitespaceRegex_ = /\\s/;\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastEquality = null;\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastEquality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastEquality = null;\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastEquality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastEquality.length < this.Diff_EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastEquality = null;\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n  // Add a dummy entry at the end.\n  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,\n                    text_insert.substring(0, commonlength)));\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          pointer -= count_delete + count_insert;\n          diffs.splice(pointer, count_delete + count_insert);\n          if (text_delete.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_DELETE, text_delete));\n            pointer++;\n          }\n          if (text_insert.length) {\n            diffs.splice(pointer, 0,\n                new diff_match_patch.Diff(DIFF_INSERT, text_insert));\n            pointer++;\n          }\n          pointer++;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n  var html = [];\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_para = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] =\n              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);\n        } else {\n          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n  // Check for null inputs.\n  if (text == null || pattern == null || loc == null) {\n    throw new Error('Null input. (match_main)');\n  }\n\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text == pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0;\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc;\n  } else {\n    // Do a fuzzy compare.\n    return this.match_bitap_(text, pattern, loc);\n  }\n};\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n  if (pattern.length > this.Match_MaxBits) {\n    throw new Error('Pattern too long for this browser.');\n  }\n\n  // Initialise the alphabet.\n  var s = this.match_alphabet_(pattern);\n\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length;\n    var proximity = Math.abs(loc - x);\n    if (!dmp.Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + (proximity / dmp.Match_Distance);\n  }\n\n  // Highest score beyond which we give up.\n  var score_threshold = this.Match_Threshold;\n  // Is there a nearby exact match? (speedup)\n  var best_loc = text.indexOf(pattern, loc);\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc != -1) {\n      score_threshold =\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << (pattern.length - 1);\n  best_loc = -1;\n\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {  // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n      } else {  // Subsequent passes: fuzzy match.\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1);\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n    last_rd = rd;\n  }\n  return best_loc;\n};\n\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n  var s = {};\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0;\n  }\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n  }\n  return s;\n};\n\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n  if (text.length == 0) {\n    return;\n  }\n  if (patch.start2 === null) {\n    throw Error('patch not initialized');\n  }\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  var padding = 0;\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\n         this.Patch_Margin) {\n    padding += this.Patch_Margin;\n    pattern = text.substring(patch.start2 - padding,\n                             patch.start2 + patch.length1 + padding);\n  }\n  // Add one chunk for good luck.\n  padding += this.Patch_Margin;\n\n  // Add the prefix.\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix) {\n    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));\n  }\n  // Add the suffix.\n  var suffix = text.substring(patch.start2 + patch.length1,\n                              patch.start2 + patch.length1 + padding);\n  if (suffix) {\n    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));\n  }\n\n  // Roll back the start points.\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  // Extend the lengths.\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n};\n\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n  var text1, diffs;\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\n      typeof opt_c == 'undefined') {\n    // Method 1: text1, text2\n    // Compute diffs from text1 and text2.\n    text1 = /** @type {string} */(a);\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n    if (diffs.length > 2) {\n      this.diff_cleanupSemantic(diffs);\n      this.diff_cleanupEfficiency(diffs);\n    }\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n      typeof opt_c == 'undefined') {\n    // Method 2: diffs\n    // Compute text1 from diffs.\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n    text1 = this.diff_text1(diffs);\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n      typeof opt_c == 'undefined') {\n    // Method 3: text1, diffs\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n      opt_c && typeof opt_c == 'object') {\n    // Method 4: text1, text2, diffs\n    // text2 is not used.\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n  } else {\n    throw new Error('Unknown call format to patch_make.');\n  }\n\n  if (diffs.length === 0) {\n    return [];  // Get rid of the null case.\n  }\n  var patches = [];\n  var patch = new diff_match_patch.patch_obj();\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n  var char_count1 = 0;  // Number of characters into the text1 string.\n  var char_count2 = 0;  // Number of characters into the text2 string.\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\n  // context info.\n  var prepatch_text = text1;\n  var postpatch_text = text1;\n  for (var x = 0; x < diffs.length; x++) {\n    var diff_type = diffs[x][0];\n    var diff_text = diffs[x][1];\n\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                         postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) +\n                         postpatch_text.substring(char_count2 +\n                             diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * this.Patch_Margin &&\n            patchDiffLength && diffs.length != x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n            patch = new diff_match_patch.patch_obj();\n            patchDiffLength = 0;\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // https://github.com/google/diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n\n    // Update the current character count.\n    if (diff_type !== DIFF_INSERT) {\n      char_count1 += diff_text.length;\n    }\n    if (diff_type !== DIFF_DELETE) {\n      char_count2 += diff_text.length;\n    }\n  }\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    this.patch_addContext_(patch, prepatch_text);\n    patches.push(patch);\n  }\n\n  return patches;\n};\n\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\n  // Making deep copies is hard in JavaScript.\n  var patchesCopy = [];\n  for (var x = 0; x < patches.length; x++) {\n    var patch = patches[x];\n    var patchCopy = new diff_match_patch.patch_obj();\n    patchCopy.diffs = [];\n    for (var y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] =\n          new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n};\n\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\n  if (patches.length == 0) {\n    return [text, []];\n  }\n\n  // Deep copy the patches so that no changes are made to originals.\n  patches = this.patch_deepCopy(patches);\n\n  var nullPadding = this.patch_addPadding(patches);\n  text = nullPadding + text + nullPadding;\n\n  this.patch_splitMax(patches);\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  var delta = 0;\n  var results = [];\n  for (var x = 0; x < patches.length; x++) {\n    var expected_loc = patches[x].start2 + delta;\n    var text1 = this.diff_text1(patches[x].diffs);\n    var start_loc;\n    var end_loc = -1;\n    if (text1.length > this.Match_MaxBits) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                                  expected_loc);\n      if (start_loc != -1) {\n        end_loc = this.match_main(text,\n            text1.substring(text1.length - this.Match_MaxBits),\n            expected_loc + text1.length - this.Match_MaxBits);\n        if (end_loc == -1 || start_loc >= end_loc) {\n          // Can't find valid trailing context.  Drop this patch.\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = this.match_main(text, text1, expected_loc);\n    }\n    if (start_loc == -1) {\n      // No match found.  :(\n      results[x] = false;\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      // Found a match.  :)\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      var text2;\n      if (end_loc == -1) {\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      } else {\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n      }\n      if (text1 == text2) {\n        // Perfect match, just shove the replacement text in.\n        text = text.substring(0, start_loc) +\n               this.diff_text2(patches[x].diffs) +\n               text.substring(start_loc + text1.length);\n      } else {\n        // Imperfect match.  Run a diff to get a framework of equivalent\n        // indices.\n        var diffs = this.diff_main(text1, text2, false);\n        if (text1.length > this.Match_MaxBits &&\n            this.diff_levenshtein(diffs) / text1.length >\n            this.Patch_DeleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false;\n        } else {\n          this.diff_cleanupSemanticLossless(diffs);\n          var index1 = 0;\n          var index2;\n          for (var y = 0; y < patches[x].diffs.length; y++) {\n            var mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = this.diff_xIndex(diffs, index1);\n            }\n            if (mod[0] === DIFF_INSERT) {  // Insertion\n              text = text.substring(0, start_loc + index2) + mod[1] +\n                     text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\n              text = text.substring(0, start_loc + index2) +\n                     text.substring(start_loc + this.diff_xIndex(diffs,\n                         index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length;\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n};\n\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\n  var paddingLength = this.Patch_Margin;\n  var nullPadding = '';\n  for (var x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x);\n  }\n\n  // Bump all the patches forward.\n  for (var x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n\n  // Add some padding on start of first diff.\n  var patch = patches[0];\n  var diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.start1 -= paddingLength;  // Should be 0.\n    patch.start2 -= paddingLength;  // Should be 0.\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    var extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  return nullPadding;\n};\n\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\n  var patch_size = this.Match_MaxBits;\n  for (var x = 0; x < patches.length; x++) {\n    if (patches[x].length1 <= patch_size) {\n      continue;\n    }\n    var bigpatch = patches[x];\n    // Remove the big old patch.\n    patches.splice(x--, 1);\n    var start1 = bigpatch.start1;\n    var start2 = bigpatch.start2;\n    var precontext = '';\n    while (bigpatch.diffs.length !== 0) {\n      // Create one of several smaller patches.\n      var patch = new diff_match_patch.patch_obj();\n      var empty = true;\n      patch.start1 = start1 - precontext.length;\n      patch.start2 = start2 - precontext.length;\n      if (precontext !== '') {\n        patch.length1 = patch.length2 = precontext.length;\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));\n      }\n      while (bigpatch.diffs.length !== 0 &&\n             patch.length1 < patch_size - this.Patch_Margin) {\n        var diff_type = bigpatch.diffs[0][0];\n        var diff_text = bigpatch.diffs[0][1];\n        if (diff_type === DIFF_INSERT) {\n          // Insertions are harmless.\n          patch.length2 += diff_text.length;\n          start2 += diff_text.length;\n          patch.diffs.push(bigpatch.diffs.shift());\n          empty = false;\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n                   patch.diffs[0][0] == DIFF_EQUAL &&\n                   diff_text.length > 2 * patch_size) {\n          // This is a large deletion.  Let it pass in one chunk.\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          empty = false;\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          bigpatch.diffs.shift();\n        } else {\n          // Deletion or equality.  Only take as much as we can stomach.\n          diff_text = diff_text.substring(0,\n              patch_size - patch.length1 - this.Patch_Margin);\n          patch.length1 += diff_text.length;\n          start1 += diff_text.length;\n          if (diff_type === DIFF_EQUAL) {\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n          } else {\n            empty = false;\n          }\n          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));\n          if (diff_text == bigpatch.diffs[0][1]) {\n            bigpatch.diffs.shift();\n          } else {\n            bigpatch.diffs[0][1] =\n                bigpatch.diffs[0][1].substring(diff_text.length);\n          }\n        }\n      }\n      // Compute the head context for the next patch.\n      precontext = this.diff_text2(patch.diffs);\n      precontext =\n          precontext.substring(precontext.length - this.Patch_Margin);\n      // Append the end context for this patch.\n      var postcontext = this.diff_text1(bigpatch.diffs)\n                            .substring(0, this.Patch_Margin);\n      if (postcontext !== '') {\n        patch.length1 += postcontext.length;\n        patch.length2 += postcontext.length;\n        if (patch.diffs.length !== 0 &&\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\n        } else {\n          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));\n        }\n      }\n      if (!empty) {\n        patches.splice(++x, 0, patch);\n      }\n    }\n  }\n};\n\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function(patches) {\n  var text = [];\n  for (var x = 0; x < patches.length; x++) {\n    text[x] = patches[x];\n  }\n  return text.join('');\n};\n\n\n/**\n * Parse a textual representation of patches and return a list of Patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function(textline) {\n  var patches = [];\n  if (!textline) {\n    return patches;\n  }\n  var text = textline.split('\\n');\n  var textPointer = 0;\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    var m = text[textPointer].match(patchHeader);\n    if (!m) {\n      throw new Error('Invalid patch string: ' + text[textPointer]);\n    }\n    var patch = new diff_match_patch.patch_obj();\n    patches.push(patch);\n    patch.start1 = parseInt(m[1], 10);\n    if (m[2] === '') {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] == '0') {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = parseInt(m[2], 10);\n    }\n\n    patch.start2 = parseInt(m[3], 10);\n    if (m[4] === '') {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] == '0') {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = parseInt(m[4], 10);\n    }\n    textPointer++;\n\n    while (textPointer < text.length) {\n      var sign = text[textPointer].charAt(0);\n      try {\n        var line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error('Illegal escape in patch_fromText: ' + line);\n      }\n      if (sign == '-') {\n        // Deletion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));\n      } else if (sign == '+') {\n        // Insertion.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));\n      } else if (sign == ' ') {\n        // Minor equality.\n        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));\n      } else if (sign == '@') {\n        // Start of next patch.\n        break;\n      } else if (sign === '') {\n        // Blank line?  Whatever.\n      } else {\n        // WTF?\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n};\n\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function() {\n  /** @type {!Array.<!diff_match_patch.Diff>} */\n  this.diffs = [];\n  /** @type {?number} */\n  this.start1 = null;\n  /** @type {?number} */\n  this.start2 = null;\n  /** @type {number} */\n  this.length1 = 0;\n  /** @type {number} */\n  this.length2 = 0;\n};\n\n\n/**\n * Emulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indices are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function() {\n  var coords1, coords2;\n  if (this.length1 === 0) {\n    coords1 = this.start1 + ',0';\n  } else if (this.length1 == 1) {\n    coords1 = this.start1 + 1;\n  } else {\n    coords1 = (this.start1 + 1) + ',' + this.length1;\n  }\n  if (this.length2 === 0) {\n    coords2 = this.start2 + ',0';\n  } else if (this.length2 == 1) {\n    coords2 = this.start2 + 1;\n  } else {\n    coords2 = (this.start2 + 1) + ',' + this.length2;\n  }\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n  var op;\n  // Escape the body of the patch with %xx notation.\n  for (var x = 0; x < this.diffs.length; x++) {\n    switch (this.diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+';\n        break;\n      case DIFF_DELETE:\n        op = '-';\n        break;\n      case DIFF_EQUAL:\n        op = ' ';\n        break;\n    }\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n  }\n  return text.join('').replace(/%20/g, ' ');\n};\n\n\n// The following export code was added by @ForbesLindesay\nmodule.exports = diff_match_patch;\nmodule.exports['diff_match_patch'] = diff_match_patch;\nmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\nmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\nmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;","/**\n * Simple is object check.\n * @param item\n * @returns {boolean}\n */\nfunction isObject(item) {\n  return (item && typeof item === 'object' && !Array.isArray(item) && item !== null);\n}\n\n\n/**\n* Deep merge two objects.\n* @param target\n* @param source\n*/\nmodule.exports = function merge(target, source) {\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isObject(source[key])) {\n        if (!target[key] || !isObject(target[key])) {\n          target[key] = source[key];\n        }\n        merge(target[key], source[key]);\n      } else {\n        Object.assign(target, { [key]: source[key] });\n      }\n    });\n  }\n  return target;\n};\n","module.exports = function throttle(callback, wait, immediate = false) {\n  let timeout = null;\n  let initialCall = true;\n\n  return (...args) => {\n    const callNow = immediate && initialCall;\n    const next = () => {\n      callback.apply(this, args);\n      timeout = null;\n    };\n\n    if (callNow) {\n      initialCall = false;\n      next();\n    }\n\n    if (!timeout) {\n      timeout = setTimeout(next, wait);\n    }\n  };\n};\n","module.exports = function debounce(callback, wait) {\n  let timeout;\n  return (...args) => {\n    const context = this;\n    clearTimeout(timeout);\n    timeout = setTimeout(() => callback.apply(context, args), wait);\n  };\n};\n","module.exports = function normalizeContent(value = '') {\n  const normalized = value.replace(/\\r\\n/g, '\\n');\n  return normalized;\n};\n","// generates a Bezier curve in SVG format\nmodule.exports = function getCurve(startX, startY, endX, endY) {\n  const w = endX - startX;\n  const halfWidth = startX + w / 2;\n\n  // now create the curve\n  // position it at the initial x,y coords\n  // This is of the form \"C M,N O,P Q,R\" where C is a directive for SVG (\"curveto\"),\n  // M,N are the first curve control point, O,P the second control point\n  // and Q,R are the final coords\n\n  return `M ${startX} ${startY} C ${halfWidth},${startY} ${halfWidth},${endY} ${endX},${endY}`;\n};\n","module.exports = {\n  DIFF_EQUAL: 0,\n  DIFF_DELETE: -1,\n  DIFF_INSERT: 1,\n  EDITOR_RIGHT: 'right',\n  EDITOR_LEFT: 'left',\n  RTL: 'rtl',\n  LTR: 'ltr',\n  SVG_NS: 'http://www.w3.org/2000/svg',\n  DIFF_GRANULARITY_SPECIFIC: 'specific',\n  DIFF_GRANULARITY_BROAD: 'broad',\n};\n","const C = require('../constants');\n\nmodule.exports = function getMode(acediff, editor) {\n  let { mode } = acediff.options;\n  if (editor === C.EDITOR_LEFT && acediff.options.left.mode !== null) {\n    mode = acediff.options.left.mode;\n  }\n  if (editor === C.EDITOR_RIGHT && acediff.options.right.mode !== null) {\n    mode = acediff.options.right.mode;\n  }\n  return mode;\n};\n","const C = require('../constants');\n\nmodule.exports = function getTheme(acediff, editor) {\n  let { theme } = acediff.options;\n  if (editor === C.EDITOR_LEFT && acediff.options.left.theme !== null) {\n    theme = acediff.options.left.theme;\n  }\n  if (editor === C.EDITOR_RIGHT && acediff.options.right.theme !== null) {\n    theme = acediff.options.right.theme;\n  }\n  return theme;\n};\n","module.exports = function getLine(editor, line) {\n  return editor.ace.getSession().doc.getLine(line);\n};\n","module.exports = function getEditorHeight(acediff) {\n  // editorHeight: document.getElementById(acediff.options.left.id).clientHeight\n  return document.getElementById(acediff.options.left.id).offsetHeight;\n};\n","module.exports = function createArrow(info) {\n  const el = document.createElement('div');\n  const props = {\n    class: info.className,\n    style: `top:${info.topOffset}px`,\n    title: info.tooltip,\n    'data-diff-index': info.diffIndex,\n  };\n  for (const key in props) {\n    el.setAttribute(key, props[key]);\n  }\n  el.innerHTML = info.arrowContent;\n  return el;\n};\n","/**\n * Search for element in parent and create it if it can't be found\n * @param {*HTMLElement} parent\n * @param {string} elClass Element class\n *\n * Returns ID of the element\n */\nmodule.exports = function ensureElement(parent, elClass) {\n  const guid = Math.random().toString(36).substr(2, 5);\n  const newId = `js-${elClass}-${guid}`;\n\n  const currentEl = parent.querySelector(`.${elClass}`);\n  if (currentEl) {\n    currentEl.id = currentEl.id || newId;\n    return currentEl.id;\n  }\n\n  const el = document.createElement('div');\n  parent.appendChild(el);\n  el.className = elClass;\n  el.id = newId;\n  return el.id;\n};\n","function on(elSelector, eventName, selector, fn) {\n  const element = (elSelector === 'document') ? document : document.querySelector(elSelector);\n\n  element.addEventListener(eventName, (event) => {\n    const possibleTargets = element.querySelectorAll(selector);\n    const { target } = event;\n\n    for (let i = 0, l = possibleTargets.length; i < l; i += 1) {\n      let el = target;\n      const p = possibleTargets[i];\n\n      while (el && el !== element) {\n        if (el === p) {\n          fn.call(p, event);\n        }\n        el = el.parentNode;\n      }\n    }\n  });\n}\n\nmodule.exports = {\n  on,\n};\n","/* eslint-disable no-use-before-define */\n/* eslint-disable no-console */\n/* eslint-disable max-len */\n\n// Diffing library\nconst DiffMatchPatch = require('diff-match-patch');\n\nconst merge = require('./helpers/merge');\nconst throttle = require('./helpers/throttle');\nconst debounce = require('./helpers/debounce');\nconst normalizeContent = require('./helpers/normalizeContent');\n\nconst getCurve = require('./visuals/getCurve');\nconst getMode = require('./visuals/getMode');\nconst getTheme = require('./visuals/getTheme');\nconst getLine = require('./visuals/getLine');\nconst getEditorHeight = require('./visuals/getEditorHeight');\nconst createArrow = require('./visuals/createArrow');\n\nconst ensureElement = require('./dom/ensureElement');\nconst query = require('./dom/query');\nconst C = require('./constants');\n\n// Range module placeholder\nlet Range;\n\nfunction getRangeModule(ace) {\n  if (ace.Range) {\n    return ace.Range;\n  }\n\n  const requireFunc = (ace.acequire || ace.require);\n  if (requireFunc) {\n    return requireFunc('ace/range');\n  }\n\n  return false;\n}\n\n// our constructor\nfunction AceDiff(options = {}) {\n  // Ensure instance is a constructor with `new`\n  if (!(this instanceof AceDiff)) {\n    return new AceDiff(options);\n  }\n\n  // Current instance we pass around to other functions\n  const acediff = this;\n  const getDefaultAce = () => (window ? window.ace : undefined);\n\n  acediff.options = merge({\n    ace: getDefaultAce(),\n    mode: null,\n    theme: null,\n    element: null,\n    diffGranularity: C.DIFF_GRANULARITY_BROAD,\n    lockScrolling: false, // not implemented yet\n    showDiffs: true,\n    showConnectors: true,\n    maxDiffs: 5000,\n    left: {\n      id: null,\n      content: null,\n      mode: null,\n      theme: null,\n      editable: true,\n      copyLinkEnabled: true,\n    },\n    right: {\n      id: null,\n      content: null,\n      mode: null,\n      theme: null,\n      editable: true,\n      copyLinkEnabled: true,\n    },\n    classes: {\n      gutterID: 'acediff__gutter',\n      diff: 'acediff__diffLine',\n      connector: 'acediff__connector',\n      newCodeConnectorLink: 'acediff__newCodeConnector',\n      newCodeConnectorLinkContent: '&#8594;',\n      deletedCodeConnectorLink: 'acediff__deletedCodeConnector',\n      deletedCodeConnectorLinkContent: '&#8592;',\n      copyRightContainer: 'acediff__copy--right',\n      copyLeftContainer: 'acediff__copy--left',\n    },\n    connectorYOffset: 0,\n  }, options);\n\n  const { ace } = acediff.options;\n\n  if (!ace) {\n    const errMessage = 'No ace editor found nor supplied - `options.ace` or `window.ace` is missing';\n    console.error(errMessage);\n    return new Error(errMessage);\n  }\n\n  Range = getRangeModule(ace);\n  if (!Range) {\n    const errMessage = 'Could not require Range module for Ace. Depends on your bundling strategy, but it usually comes with Ace itself. See https://ace.c9.io/api/range.html, open an issue on GitHub ace-diff/ace-diff';\n    console.error(errMessage);\n    return new Error(errMessage);\n  }\n\n  if (acediff.options.element === null) {\n    const errMessage = 'You need to specify an element for Ace-diff - `options.element` is missing';\n    console.error(errMessage);\n    return new Error(errMessage);\n  }\n\n  if (acediff.options.element instanceof HTMLElement) {\n    acediff.el = acediff.options.element;\n  } else {\n    acediff.el = document.body.querySelector(acediff.options.element);\n  }\n\n  if (!acediff.el) {\n    const errMessage = `Can't find the specified element ${acediff.options.element}`;\n    console.error(errMessage);\n    return new Error(errMessage);\n  }\n\n  acediff.options.left.id = ensureElement(acediff.el, 'acediff__left');\n  acediff.options.classes.gutterID = ensureElement(acediff.el, 'acediff__gutter');\n  acediff.options.right.id = ensureElement(acediff.el, 'acediff__right');\n\n  acediff.el.innerHTML = `<div class=\"acediff__wrap\">${acediff.el.innerHTML}</div>`;\n\n  // instantiate the editors in an internal data structure\n  // that will store a little info about the diffs and\n  // editor content\n  acediff.editors = {\n    left: {\n      ace: ace.edit(acediff.options.left.id),\n      markers: [],\n      lineLengths: [],\n    },\n    right: {\n      ace: ace.edit(acediff.options.right.id),\n      markers: [],\n      lineLengths: [],\n    },\n    editorHeight: null,\n  };\n\n\n  // set up the editors\n  acediff.editors.left.ace.getSession().setMode(getMode(acediff, C.EDITOR_LEFT));\n  acediff.editors.right.ace.getSession().setMode(getMode(acediff, C.EDITOR_RIGHT));\n  acediff.editors.left.ace.setReadOnly(!acediff.options.left.editable);\n  acediff.editors.right.ace.setReadOnly(!acediff.options.right.editable);\n  acediff.editors.left.ace.setTheme(getTheme(acediff, C.EDITOR_LEFT));\n  acediff.editors.right.ace.setTheme(getTheme(acediff, C.EDITOR_RIGHT));\n\n  acediff.editors.left.ace.setValue(normalizeContent(acediff.options.left.content), -1);\n  acediff.editors.right.ace.setValue(normalizeContent(acediff.options.right.content), -1);\n\n  // store the visible height of the editors (assumed the same)\n  acediff.editors.editorHeight = getEditorHeight(acediff);\n\n  // The lineHeight is set to 0 initially and we need to wait for another tick to get it\n  // Thus moving the diff() with it\n  setTimeout(() => {\n    // assumption: both editors have same line heights\n    acediff.lineHeight = acediff.editors.left.ace.renderer.lineHeight;\n\n    addEventHandlers(acediff);\n    createCopyContainers(acediff);\n    createGutter(acediff);\n    acediff.diff();\n  }, 1);\n}\n\n\n// our public API\nAceDiff.prototype = {\n\n  // allows on-the-fly changes to the AceDiff instance settings\n  setOptions(options) {\n    merge(this.options, options);\n    this.diff();\n  },\n\n  getNumDiffs() {\n    return this.diffs.length;\n  },\n\n  // exposes the Ace editors in case the dev needs it\n  getEditors() {\n    return {\n      left: this.editors.left.ace,\n      right: this.editors.right.ace,\n    };\n  },\n\n  // our main diffing function. I actually don't think this needs to exposed: it's called automatically,\n  // but just to be safe, it's included\n  diff() {\n    const dmp = new DiffMatchPatch();\n    const val1 = this.editors.left.ace.getSession().getValue();\n    const val2 = this.editors.right.ace.getSession().getValue();\n    const diff = dmp.diff_main(val2, val1);\n    dmp.diff_cleanupSemantic(diff);\n\n    this.editors.left.lineLengths = getLineLengths(this.editors.left);\n    this.editors.right.lineLengths = getLineLengths(this.editors.right);\n\n    // parse the raw diff into something a little more palatable\n    const diffs = [];\n    const offset = {\n      left: 0,\n      right: 0,\n    };\n\n    diff.forEach((chunk, index, array) => {\n      const chunkType = chunk[0];\n      let text = chunk[1];\n\n      // Fix for #28 https://github.com/ace-diff/ace-diff/issues/28\n      if (array[index + 1] && text.endsWith('\\n') && array[index + 1][1].startsWith('\\n')) {\n        text += '\\n';\n        diff[index][1] = text;\n        diff[index + 1][1] = diff[index + 1][1].replace(/^\\n/, '');\n      }\n\n      // oddly, occasionally the algorithm returns a diff with no changes made\n      if (text.length === 0) {\n        return;\n      }\n      if (chunkType === C.DIFF_EQUAL) {\n        offset.left += text.length;\n        offset.right += text.length;\n      } else if (chunkType === C.DIFF_DELETE) {\n        diffs.push(computeDiff(this, C.DIFF_DELETE, offset.left, offset.right, text));\n        offset.right += text.length;\n      } else if (chunkType === C.DIFF_INSERT) {\n        diffs.push(computeDiff(this, C.DIFF_INSERT, offset.left, offset.right, text));\n        offset.left += text.length;\n      }\n    }, this);\n\n    // simplify our computed diffs; this groups together multiple diffs on subsequent lines\n    this.diffs = simplifyDiffs(this, diffs);\n\n    // if we're dealing with too many diffs, fail silently\n    if (this.diffs.length > this.options.maxDiffs) {\n      return;\n    }\n\n    clearDiffs(this);\n    decorate(this);\n  },\n\n  destroy() {\n    // destroy the two editors\n    const leftValue = this.editors.left.ace.getValue();\n    this.editors.left.ace.destroy();\n    let oldDiv = this.editors.left.ace.container;\n    let newDiv = oldDiv.cloneNode(false);\n    newDiv.textContent = leftValue;\n    oldDiv.parentNode.replaceChild(newDiv, oldDiv);\n\n    const rightValue = this.editors.right.ace.getValue();\n    this.editors.right.ace.destroy();\n    oldDiv = this.editors.right.ace.container;\n    newDiv = oldDiv.cloneNode(false);\n    newDiv.textContent = rightValue;\n    oldDiv.parentNode.replaceChild(newDiv, oldDiv);\n\n    document.getElementById(this.options.classes.gutterID).innerHTML = '';\n    removeEventHandlers();\n  },\n};\n\nlet removeEventHandlers = () => { };\n\nfunction addEventHandlers(acediff) {\n  acediff.editors.left.ace.getSession().on('changeScrollTop', throttle(() => { updateGap(acediff); }, 16));\n  acediff.editors.right.ace.getSession().on('changeScrollTop', throttle(() => { updateGap(acediff); }, 16));\n\n  const diff = acediff.diff.bind(acediff);\n  acediff.editors.left.ace.on('change', diff);\n  acediff.editors.right.ace.on('change', diff);\n\n  if (acediff.options.left.copyLinkEnabled) {\n    query.on(`#${acediff.options.classes.gutterID}`, 'click', `.${acediff.options.classes.newCodeConnectorLink}`, (e) => {\n      copy(acediff, e, C.LTR);\n    });\n  }\n  if (acediff.options.right.copyLinkEnabled) {\n    query.on(`#${acediff.options.classes.gutterID}`, 'click', `.${acediff.options.classes.deletedCodeConnectorLink}`, (e) => {\n      copy(acediff, e, C.RTL);\n    });\n  }\n\n  const onResize = debounce(() => {\n    acediff.editors.availableHeight = document.getElementById(acediff.options.left.id).offsetHeight;\n\n    // TODO this should re-init gutter\n    acediff.diff();\n  }, 250);\n\n  window.addEventListener('resize', onResize);\n  removeEventHandlers = () => {\n    window.removeEventListener('resize', onResize);\n  };\n}\n\n\nfunction copy(acediff, e, dir) {\n  const diffIndex = parseInt(e.target.getAttribute('data-diff-index'), 10);\n  const diff = acediff.diffs[diffIndex];\n  let sourceEditor;\n  let targetEditor;\n\n  let startLine;\n  let endLine;\n  let targetStartLine;\n  let targetEndLine;\n  if (dir === C.LTR) {\n    sourceEditor = acediff.editors.left;\n    targetEditor = acediff.editors.right;\n    startLine = diff.leftStartLine;\n    endLine = diff.leftEndLine;\n    targetStartLine = diff.rightStartLine;\n    targetEndLine = diff.rightEndLine;\n  } else {\n    sourceEditor = acediff.editors.right;\n    targetEditor = acediff.editors.left;\n    startLine = diff.rightStartLine;\n    endLine = diff.rightEndLine;\n    targetStartLine = diff.leftStartLine;\n    targetEndLine = diff.leftEndLine;\n  }\n\n  let contentToInsert = '';\n  for (let i = startLine; i < endLine; i += 1) {\n    contentToInsert += `${getLine(sourceEditor, i)}\\n`;\n  }\n\n  // keep track of the scroll height\n  const h = targetEditor.ace.getSession().getScrollTop();\n  targetEditor.ace.getSession().replace(new Range(targetStartLine, 0, targetEndLine, 0), contentToInsert);\n  targetEditor.ace.getSession().setScrollTop(parseInt(h, 10));\n\n  acediff.diff();\n}\n\n\nfunction getLineLengths(editor) {\n  const lines = editor.ace.getSession().doc.getAllLines();\n  const lineLengths = [];\n  lines.forEach((line) => {\n    lineLengths.push(line.length + 1); // +1 for the newline char\n  });\n  return lineLengths;\n}\n\n\n// shows a diff in one of the two editors.\nfunction showDiff(acediff, editor, startLine, endLine, className) {\n  const editorInstance = acediff.editors[editor];\n\n  if (endLine < startLine) { // can this occur? Just in case.\n    endLine = startLine;\n  }\n\n  const classNames = `${className} ${(endLine > startLine) ? 'lines' : 'targetOnly'}`;\n\n  // to get Ace to highlight the full row we just set the start and end chars to 0 and 1\n  editorInstance.markers.push(\n    editorInstance.ace.session.addMarker(\n      new Range(\n        startLine,\n        0,\n        endLine - 1 /* because endLine is always + 1 */,\n        1,\n      ), classNames, 'fullLine',\n    ),\n  );\n}\n\n\n// called onscroll. Updates the gap to ensure the connectors are all lining up\nfunction updateGap(acediff) {\n  clearDiffs(acediff);\n  decorate(acediff);\n\n  // reposition the copy containers containing all the arrows\n  positionCopyContainers(acediff);\n}\n\n\nfunction clearDiffs(acediff) {\n  acediff.editors.left.markers.forEach((marker) => {\n    acediff.editors.left.ace.getSession().removeMarker(marker);\n  }, acediff);\n  acediff.editors.right.markers.forEach((marker) => {\n    acediff.editors.right.ace.getSession().removeMarker(marker);\n  }, acediff);\n}\n\n\nfunction addConnector(acediff, leftStartLine, leftEndLine, rightStartLine, rightEndLine) {\n  const leftScrollTop = acediff.editors.left.ace.getSession().getScrollTop();\n  const rightScrollTop = acediff.editors.right.ace.getSession().getScrollTop();\n\n  // All connectors, regardless of ltr or rtl\n  // have the same point system, even if p1 === p3 or p2 === p4\n  //  p1   p2\n  //\n  //  p3   p4\n\n  acediff.connectorYOffset = 1;\n\n  const p1_x = -1;\n  const p1_y = (leftStartLine * acediff.lineHeight) - leftScrollTop + 0.5;\n  const p2_x = acediff.gutterWidth + 1;\n  const p2_y = rightStartLine * acediff.lineHeight - rightScrollTop + 0.5;\n  const p3_x = -1;\n  const p3_y = (leftEndLine * acediff.lineHeight) - leftScrollTop + acediff.connectorYOffset + 0.5;\n  const p4_x = acediff.gutterWidth + 1;\n  const p4_y = (rightEndLine * acediff.lineHeight) - rightScrollTop + acediff.connectorYOffset + 0.5;\n  const curve1 = getCurve(p1_x, p1_y, p2_x, p2_y);\n  const curve2 = getCurve(p4_x, p4_y, p3_x, p3_y);\n\n  const verticalLine1 = `L${p2_x},${p2_y} ${p4_x},${p4_y}`;\n  const verticalLine2 = `L${p3_x},${p3_y} ${p1_x},${p1_y}`;\n  const d = `${curve1} ${verticalLine1} ${curve2} ${verticalLine2}`;\n\n  const el = document.createElementNS(C.SVG_NS, 'path');\n  el.setAttribute('d', d);\n  el.setAttribute('class', acediff.options.classes.connector);\n  acediff.gutterSVG.appendChild(el);\n}\n\n\nfunction addCopyArrows(acediff, info, diffIndex) {\n  if (info.leftEndLine > info.leftStartLine && acediff.options.left.copyLinkEnabled) {\n    const arrow = createArrow({\n      className: acediff.options.classes.newCodeConnectorLink,\n      topOffset: info.leftStartLine * acediff.lineHeight,\n      tooltip: 'Copy to right',\n      diffIndex,\n      arrowContent: acediff.options.classes.newCodeConnectorLinkContent,\n    });\n    acediff.copyRightContainer.appendChild(arrow);\n  }\n\n  if (info.rightEndLine > info.rightStartLine && acediff.options.right.copyLinkEnabled) {\n    const arrow = createArrow({\n      className: acediff.options.classes.deletedCodeConnectorLink,\n      topOffset: info.rightStartLine * acediff.lineHeight,\n      tooltip: 'Copy to left',\n      diffIndex,\n      arrowContent: acediff.options.classes.deletedCodeConnectorLinkContent,\n    });\n    acediff.copyLeftContainer.appendChild(arrow);\n  }\n}\n\n\nfunction positionCopyContainers(acediff) {\n  const leftTopOffset = acediff.editors.left.ace.getSession().getScrollTop();\n  const rightTopOffset = acediff.editors.right.ace.getSession().getScrollTop();\n\n  acediff.copyRightContainer.style.cssText = `top: ${-leftTopOffset}px`;\n  acediff.copyLeftContainer.style.cssText = `top: ${-rightTopOffset}px`;\n}\n\n\n/**\n // eslint-disable-next-line max-len\n * This method takes the raw diffing info from the Google lib and returns a nice clean object of the following\n * form:\n * {\n *   leftStartLine:\n *   leftEndLine:\n *   rightStartLine:\n *   rightEndLine:\n * }\n *\n * Ultimately, that's all the info we need to highlight the appropriate lines in the left + right editor, add the\n * SVG connectors, and include the appropriate <<, >> arrows.\n *\n * Note: leftEndLine and rightEndLine are always the start of the NEXT line, so for a single line diff, there will\n * be 1 separating the startLine and endLine values. So if leftStartLine === leftEndLine or rightStartLine ===\n * rightEndLine, it means that new content from the other editor is being inserted and a single 1px line will be\n * drawn.\n */\nfunction computeDiff(acediff, diffType, offsetLeft, offsetRight, diffText) {\n  let lineInfo = {};\n\n  // this was added in to hack around an oddity with the Google lib. Sometimes it would include a newline\n  // as the first char for a diff, other times not - and it would change when you were typing on-the-fly. This\n  // is used to level things out so the diffs don't appear to shift around\n  let newContentStartsWithNewline = /^\\n/.test(diffText);\n\n  if (diffType === C.DIFF_INSERT) {\n    // pretty confident this returns the right stuff for the left editor: start & end line & char\n    var info = getSingleDiffInfo(acediff.editors.left, offsetLeft, diffText);\n\n    // this is the ACTUAL undoctored current line in the other editor. It's always right. Doesn't mean it's\n    // going to be used as the start line for the diff though.\n    var currentLineOtherEditor = getLineForCharPosition(acediff.editors.right, offsetRight);\n    var numCharsOnLineOtherEditor = getCharsOnLine(acediff.editors.right, currentLineOtherEditor);\n    const numCharsOnLeftEditorStartLine = getCharsOnLine(acediff.editors.left, info.startLine);\n    var numCharsOnLine = getCharsOnLine(acediff.editors.left, info.startLine);\n\n    // this is necessary because if a new diff starts on the FIRST char of the left editor, the diff can comes\n    // back from google as being on the last char of the previous line so we need to bump it up one\n    let rightStartLine = currentLineOtherEditor;\n    if (numCharsOnLine === 0 && newContentStartsWithNewline) {\n      newContentStartsWithNewline = false;\n    }\n    if (info.startChar === 0 && isLastChar(acediff.editors.right, offsetRight, newContentStartsWithNewline)) {\n      rightStartLine = currentLineOtherEditor + 1;\n    }\n\n    var sameLineInsert = info.startLine === info.endLine;\n\n    // whether or not this diff is a plain INSERT into the other editor, or overwrites a line take a little work to\n    // figure out. This feels like the hardest part of the entire script.\n    var numRows = 0;\n    if (\n\n      // dense, but this accommodates two scenarios:\n      // 1. where a completely fresh new line is being inserted in left editor, we want the line on right to stay a 1px line\n      // 2. where a new character is inserted at the start of a newline on the left but the line contains other stuff,\n      //    we DO want to make it a full line\n      (info.startChar > 0 || (sameLineInsert && diffText.length < numCharsOnLeftEditorStartLine))\n\n      // if the right editor line was empty, it's ALWAYS a single line insert [not an OR above?]\n      && numCharsOnLineOtherEditor > 0\n\n      // if the text being inserted starts mid-line\n      && (info.startChar < numCharsOnLeftEditorStartLine)) {\n      numRows++;\n    }\n\n    lineInfo = {\n      leftStartLine: info.startLine,\n      leftEndLine: info.endLine + 1,\n      rightStartLine,\n      rightEndLine: rightStartLine + numRows,\n    };\n  } else {\n    var info = getSingleDiffInfo(acediff.editors.right, offsetRight, diffText);\n\n    var currentLineOtherEditor = getLineForCharPosition(acediff.editors.left, offsetLeft);\n    var numCharsOnLineOtherEditor = getCharsOnLine(acediff.editors.left, currentLineOtherEditor);\n    const numCharsOnRightEditorStartLine = getCharsOnLine(acediff.editors.right, info.startLine);\n    var numCharsOnLine = getCharsOnLine(acediff.editors.right, info.startLine);\n\n    // this is necessary because if a new diff starts on the FIRST char of the left editor, the diff can comes\n    // back from google as being on the last char of the previous line so we need to bump it up one\n    let leftStartLine = currentLineOtherEditor;\n    if (numCharsOnLine === 0 && newContentStartsWithNewline) {\n      newContentStartsWithNewline = false;\n    }\n    if (info.startChar === 0 && isLastChar(acediff.editors.left, offsetLeft, newContentStartsWithNewline)) {\n      leftStartLine = currentLineOtherEditor + 1;\n    }\n\n    var sameLineInsert = info.startLine === info.endLine;\n    var numRows = 0;\n    if (\n\n      // dense, but this accommodates two scenarios:\n      // 1. where a completely fresh new line is being inserted in left editor, we want the line on right to stay a 1px line\n      // 2. where a new character is inserted at the start of a newline on the left but the line contains other stuff,\n      //    we DO want to make it a full line\n      (info.startChar > 0 || (sameLineInsert && diffText.length < numCharsOnRightEditorStartLine))\n\n      // if the right editor line was empty, it's ALWAYS a single line insert [not an OR above?]\n      && numCharsOnLineOtherEditor > 0\n\n      // if the text being inserted starts mid-line\n      && (info.startChar < numCharsOnRightEditorStartLine)) {\n      numRows++;\n    }\n\n    lineInfo = {\n      leftStartLine,\n      leftEndLine: leftStartLine + numRows,\n      rightStartLine: info.startLine,\n      rightEndLine: info.endLine + 1,\n    };\n  }\n\n  return lineInfo;\n}\n\n\n// helper to return the startline, endline, startChar and endChar for a diff in a particular editor. Pretty\n// fussy function\nfunction getSingleDiffInfo(editor, offset, diffString) {\n  const info = {\n    startLine: 0,\n    startChar: 0,\n    endLine: 0,\n    endChar: 0,\n  };\n  const endCharNum = offset + diffString.length;\n  let runningTotal = 0;\n  let startLineSet = false;\n  let endLineSet = false;\n\n  editor.lineLengths.forEach((lineLength, lineIndex) => {\n    runningTotal += lineLength;\n\n    if (!startLineSet && offset < runningTotal) {\n      info.startLine = lineIndex;\n      info.startChar = offset - runningTotal + lineLength;\n      startLineSet = true;\n    }\n\n    if (!endLineSet && endCharNum <= runningTotal) {\n      info.endLine = lineIndex;\n      info.endChar = endCharNum - runningTotal + lineLength;\n      endLineSet = true;\n    }\n  });\n\n  // if the start char is the final char on the line, it's a newline & we ignore it\n  if (info.startChar > 0 && getCharsOnLine(editor, info.startLine) === info.startChar) {\n    info.startLine++;\n    info.startChar = 0;\n  }\n\n  // if the end char is the first char on the line, we don't want to highlight that extra line\n  if (info.endChar === 0) {\n    info.endLine--;\n  }\n\n  const endsWithNewline = /\\n$/.test(diffString);\n  if (info.startChar > 0 && endsWithNewline) {\n    info.endLine++;\n  }\n\n  return info;\n}\n\n\n// note that this and everything else in this script uses 0-indexed row numbers\nfunction getCharsOnLine(editor, line) {\n  return getLine(editor, line).length;\n}\n\n\nfunction getLineForCharPosition(editor, offsetChars) {\n  const lines = editor.ace.getSession().doc.getAllLines();\n  let foundLine = 0;\n  let runningTotal = 0;\n\n  for (let i = 0; i < lines.length; i += 1) {\n    runningTotal += lines[i].length + 1; // +1 needed for newline char\n    if (offsetChars <= runningTotal) {\n      foundLine = i;\n      break;\n    }\n  }\n  return foundLine;\n}\n\n\nfunction isLastChar(editor, char, startsWithNewline) {\n  const lines = editor.ace.getSession().doc.getAllLines();\n  let runningTotal = 0;\n\n  for (let i = 0; i < lines.length; i += 1) {\n    runningTotal += lines[i].length + 1; // +1 needed for newline char\n    let comparison = runningTotal;\n    if (startsWithNewline) {\n      comparison -= 1;\n    }\n\n    if (char === comparison) {\n      break;\n    }\n  }\n  return isLastChar;\n}\n\nfunction createGutter(acediff) {\n  acediff.gutterHeight = document.getElementById(acediff.options.classes.gutterID).clientHeight;\n  acediff.gutterWidth = document.getElementById(acediff.options.classes.gutterID).clientWidth;\n\n  const leftHeight = getTotalHeight(acediff, C.EDITOR_LEFT);\n  const rightHeight = getTotalHeight(acediff, C.EDITOR_RIGHT);\n  const height = Math.max(leftHeight, rightHeight, acediff.gutterHeight);\n\n  acediff.gutterSVG = document.createElementNS(C.SVG_NS, 'svg');\n  acediff.gutterSVG.setAttribute('width', acediff.gutterWidth);\n  acediff.gutterSVG.setAttribute('height', height);\n\n  document.getElementById(acediff.options.classes.gutterID).appendChild(acediff.gutterSVG);\n}\n\n// acediff.editors.left.ace.getSession().getLength() * acediff.lineHeight\nfunction getTotalHeight(acediff, editor) {\n  const ed = (editor === C.EDITOR_LEFT) ? acediff.editors.left : acediff.editors.right;\n  return ed.ace.getSession().getLength() * acediff.lineHeight;\n}\n\n// creates two contains for positioning the copy left + copy right arrows\nfunction createCopyContainers(acediff) {\n  acediff.copyRightContainer = document.createElement('div');\n  acediff.copyRightContainer.setAttribute('class', acediff.options.classes.copyRightContainer);\n  acediff.copyLeftContainer = document.createElement('div');\n  acediff.copyLeftContainer.setAttribute('class', acediff.options.classes.copyLeftContainer);\n\n  document.getElementById(acediff.options.classes.gutterID).appendChild(acediff.copyRightContainer);\n  document.getElementById(acediff.options.classes.gutterID).appendChild(acediff.copyLeftContainer);\n}\n\n\nfunction clearGutter(acediff) {\n  // gutter.innerHTML = '';\n\n  const gutterEl = document.getElementById(acediff.options.classes.gutterID);\n  gutterEl.removeChild(acediff.gutterSVG);\n\n  createGutter(acediff);\n}\n\n\nfunction clearArrows(acediff) {\n  acediff.copyLeftContainer.innerHTML = '';\n  acediff.copyRightContainer.innerHTML = '';\n}\n\n\n/*\n  * This combines multiple rows where, say, line 1 => line 1, line 2 => line 2, line 3-4 => line 3. That could be\n  * reduced to a single connector line 1=4 => line 1-3\n  */\nfunction simplifyDiffs(acediff, diffs) {\n  const groupedDiffs = [];\n\n  function compare(val) {\n    return (acediff.options.diffGranularity === C.DIFF_GRANULARITY_SPECIFIC) ? val < 1 : val <= 1;\n  }\n\n  diffs.forEach((diff, index) => {\n    if (index === 0) {\n      groupedDiffs.push(diff);\n      return;\n    }\n\n    // loop through all grouped diffs. If this new diff lies between an existing one, we'll just add to it, rather\n    // than create a new one\n    let isGrouped = false;\n    for (let i = 0; i < groupedDiffs.length; i += 1) {\n      if (compare(Math.abs(diff.leftStartLine - groupedDiffs[i].leftEndLine))\n        && compare(Math.abs(diff.rightStartLine - groupedDiffs[i].rightEndLine))) {\n        // update the existing grouped diff to expand its horizons to include this new diff start + end lines\n        groupedDiffs[i].leftStartLine = Math.min(diff.leftStartLine, groupedDiffs[i].leftStartLine);\n        groupedDiffs[i].rightStartLine = Math.min(diff.rightStartLine, groupedDiffs[i].rightStartLine);\n        groupedDiffs[i].leftEndLine = Math.max(diff.leftEndLine, groupedDiffs[i].leftEndLine);\n        groupedDiffs[i].rightEndLine = Math.max(diff.rightEndLine, groupedDiffs[i].rightEndLine);\n        isGrouped = true;\n        break;\n      }\n    }\n\n    if (!isGrouped) {\n      groupedDiffs.push(diff);\n    }\n  });\n\n  // clear out any single line diffs (i.e. single line on both editors)\n  const fullDiffs = [];\n  groupedDiffs.forEach((diff) => {\n    if (diff.leftStartLine === diff.leftEndLine && diff.rightStartLine === diff.rightEndLine) {\n      return;\n    }\n    fullDiffs.push(diff);\n  });\n\n  return fullDiffs;\n}\n\n\nfunction decorate(acediff) {\n  clearGutter(acediff);\n  clearArrows(acediff);\n\n  acediff.diffs.forEach((info, diffIndex) => {\n    if (acediff.options.showDiffs) {\n      showDiff(acediff, C.EDITOR_LEFT, info.leftStartLine, info.leftEndLine, acediff.options.classes.diff);\n      showDiff(acediff, C.EDITOR_RIGHT, info.rightStartLine, info.rightEndLine, acediff.options.classes.diff);\n\n      if (acediff.options.showConnectors) {\n        addConnector(acediff, info.leftStartLine, info.leftEndLine, info.rightStartLine, info.rightEndLine);\n      }\n      addCopyArrows(acediff, info, diffIndex);\n    }\n  }, acediff);\n}\n\nmodule.exports = AceDiff;\n"]}